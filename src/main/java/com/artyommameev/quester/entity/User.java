package com.artyommameev.quester.entity;

import com.artyommameev.quester.util.EmailChecker;
import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.core.oidc.user.OidcUser;

import javax.persistence.*;
import javax.validation.constraints.Size;
import java.util.*;
import java.util.stream.Collectors;

import static com.artyommameev.quester.QuesterApplication.*;

/**
 * A User domain entity. Encapsulates an user of the service.
 *
 * @author Artyom Mameev
 */
@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)
public final class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Getter
    @SuppressWarnings("unused") // assigned by db
    private long id;

    @Column(unique = true)
    @Size(min = MIN_STRING_SIZE, max = MAX_SHORT_STRING_SIZE)
    @Getter
    private String username;

    @Column(unique = true)
    @Size(min = MIN_STRING_SIZE, max = MAX_SHORT_STRING_SIZE)
    @Getter
    private String email;

    @Size(min = MIN_STRING_SIZE, max = MAX_LONG_STRING_SIZE)
    @Getter
    private String password;

    @Column(updatable = false)
    @Getter
    private String googleUsername;

    @Column(unique = true, updatable = false)
    @Getter
    private String googleEmail;

    @ElementCollection(fetch = FetchType.EAGER)
    private List<GrantedAuthority> authorities;

    @SuppressWarnings("unused") // used by bd trigger
    @Column(insertable = false, updatable = false)
    @Getter
    // generated by trigger in the bd
    private Double rating;

    @Getter
    private boolean accountNonExpired;

    @Getter
    private boolean accountNonLocked;

    @Getter
    private boolean credentialsNonExpired;

    @Getter
    private boolean enabled;

    // 'Collection' type selected for performance reasons -
    // no items are added or removed to these collections (besides clearing
    // the whole collections)
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "user",
            fetch = FetchType.LAZY)
    private final Collection<Game> games = new ArrayList<>();
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "user",
            fetch = FetchType.LAZY)
    private final Collection<Review> reviews = new HashSet<>();
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "user",
            fetch = FetchType.LAZY)
    private final Collection<Comment> comments = new ArrayList<>();

    /**
     * Creates a new non-expired, non-locked, enabled User.
     * <p>
     * After the object is created, it must be saved in the database
     * to be assigned a unique id.
     *
     * @param username         a user name.
     * @param email            an email of the user.
     * @param password         a password of the user.
     * @param matchingPassword a matching password.
     * @param passwordEncoder  the password encoder.
     * @param authorities      a list of the user authorities.
     * @throws EmptyStringException       if any string parameter is empty.
     * @throws NullValueException         if any parameter is null.
     * @throws EmailFormatException       if the email format is incorrect.
     * @throws PasswordsNotMatchException if the passwords does not match.
     */
    public User(String username, String email, String password,
                String matchingPassword, @NonNull PasswordEncoder passwordEncoder,
                @NonNull List<String> authorities) throws EmptyStringException,
            EmailFormatException, PasswordsNotMatchException, NullValueException {
        updateUsername(username);
        updatePassword(password, matchingPassword, passwordEncoder);
        updateEmail(email);
        setAuthorities(authorities);
        accountNonExpired = accountNonLocked = credentialsNonExpired =
                enabled = true;
    }

    /**
     * Creates a non-expired, non-locked, enabled normal User with general user
     * authorities from {@link OidcUser}.
     *
     * @param oidcUser the Oidc user from which the User should be created.
     * @return the normal User created from the {@link OidcUser}.
     */
    public static User fromGoogleOidcUser(@NonNull OidcUser oidcUser) {
        val user = new User();

        user.setGoogleUsername(Objects.requireNonNull(
                oidcUser.getAttribute("name")));
        user.setGoogleEmail(Objects.requireNonNull(
                oidcUser.getAttribute("email")));
        user.setAuthorities(Collections.singletonList("ROLE_USER"));
        user.accountNonExpired = user.accountNonLocked =
                user.credentialsNonExpired = user.enabled = true;

        return user;
    }

    /**
     * Sets the username of the user if it has not been set before.
     *
     * @param username the user name.
     * @throws EmptyStringException    if the username is empty.
     * @throws NullValueException      if the username is null.
     * @throws UsernameExistsException if the username already has been set.
     */
    public void confirmUsername(String username) throws EmptyStringException,
            UsernameExistsException, NullValueException {
        if (this.username != null) {
            throw new UsernameExistsException("User with username " +
                    username + " already exists");
        }

        updateUsername(username);
    }

    /**
     * Changes the username of the user.
     *
     * @param username a new user name.
     * @throws EmptyStringException if the new username is empty.
     * @throws NullValueException   if the new username is null.
     */
    public void updateUsername(String username) throws EmptyStringException,
            NullValueException {
        if (username == null) {
            throw new NullValueException("Username cannot be null");
        }
        if (username.trim().isEmpty()) {
            throw new EmptyStringException("Username cannot be empty");
        }

        this.username = username.trim();
    }

    /**
     * Changes the user password.
     *
     * @param password         a new user password.
     * @param matchingPassword the matching password.
     * @param passwordEncoder  the password encoder.
     * @throws EmptyStringException       if any password string value is empty.
     * @throws NullValueException         if any password value is null.
     * @throws PasswordsNotMatchException if the passwords does not match.
     */
    public void updatePassword(String password, String matchingPassword,
                               @NonNull PasswordEncoder passwordEncoder)
            throws EmptyStringException, PasswordsNotMatchException,
            NullValueException {
        if (password == null || matchingPassword == null) {
            throw new NullValueException("Password and matching password " +
                    "cannot be null");
        }
        if (password.isEmpty() || matchingPassword.isEmpty()) {
            throw new EmptyStringException("Password and matching password " +
                    "cannot be empty");
        }
        if (!password.equals(matchingPassword)) {
            throw new PasswordsNotMatchException("Passwords must match with " +
                    "each other");
        }

        this.password = passwordEncoder.encode(password);
    }

    /**
     * Changes the user email.
     *
     * @param email a new user email.
     * @throws EmailFormatException if the email has a wrong format.
     * @throws NullValueException   if the email is null.
     */
    public void updateEmail(String email) throws EmailFormatException,
            NullValueException {
        if (email == null) {
            throw new NullValueException("E-mail cannot be null");
        }
        if (!EmailChecker.isEmail(email.trim())) {
            throw new EmailFormatException("Wrong E-mail format");
        }

        this.email = email.trim();
    }

    /**
     * Returns the user authorities.
     *
     * @return the user authorities in a unmodifiable list.
     */
    @Override
    public List<GrantedAuthority> getAuthorities() {
        return Collections.unmodifiableList(authorities);
    }

    private void setAuthorities(List<String> roles) {
        if (roles.isEmpty()) {
            throw new NoAuthoritiesException("Authorities list cannot be" +
                    " empty");
        }

        authorities = new ArrayList<>();

        for (String role : roles) {
            if (role.isEmpty()) {
                throw new EmptyAuthorityException("Authority cannot be empty");
            }

            authorities.add(new SimpleGrantedAuthority(role));
        }
    }

    /**
     * Checks if the user is admin.
     *
     * @return true if the user is admin, otherwise false.
     */
    public boolean isAdmin() {
        for (GrantedAuthority authority : authorities) {
            if (authority.getAuthority().equals("ROLE_ADMIN")) {
                return true;
            }
        }

        return false;
    }

    /**
     * Removes all {@link Game}s created by the user.
     * <p>
     * This operation is only allowed to admin users.
     *
     * @param user a user who tries to remove all {@link Game}s from this user.
     * @throws ForbiddenManipulationException if the user is not allowed to
     *                                        remove all {@link Game}s from
     *                                        this user.
     */
    public void clearGames(@NonNull User user)
            throws ForbiddenManipulationException {
        if (!user.isAdmin()) {
            throw new ForbiddenManipulationException("User cannot modify" +
                    " the data of the user " + username);
        }

        games.clear();
    }

    /**
     * Removes all {@link Review}s created by the user.
     * <p>
     * This operation is only allowed to admin users.
     *
     * @param user a user who tries to remove all {@link Review}s from this
     *             user.
     * @throws ForbiddenManipulationException if the user is not allowed to
     *                                        remove all {@link Review}s from
     *                                        this user.
     */
    public void clearReviews(@NonNull User user)
            throws ForbiddenManipulationException {
        if (!user.isAdmin()) {
            throw new ForbiddenManipulationException("User cannot modify" +
                    " the data of the user " + username);
        }

        reviews.clear();
    }

    /**
     * Removes all {@link Comment}s created by the user.
     * <p>
     * This operation is only allowed to admin users.
     *
     * @param user a user who tries to remove all {@link Comment}s from
     *             this user.
     * @throws ForbiddenManipulationException if the user is not allowed to
     *                                        remove all {@link Comment}s from
     *                                        this user.
     */
    public void clearComments(@NonNull User user)
            throws ForbiddenManipulationException {
        if (!user.isAdmin()) {
            throw new ForbiddenManipulationException("User cannot modify" +
                    " the data of the user " + username);
        }

        comments.clear();
    }

    /**
     * Changes the enabled status of the user.
     * <p>
     * This operation is only allowed to admin users.<br>
     * Changing the enabled status of admin users is prohibited.
     *
     * @param enabled a boolean that represents the user's enabled status.
     * @param user    a user that tries to change the enabled status
     *                of this user.
     * @throws ForbiddenManipulationException if the user is not allowed to
     *                                        change the enabled status
     *                                        of this user.
     */
    public void setEnabled(boolean enabled, @NonNull User user)
            throws ForbiddenManipulationException {
        if (!user.isAdmin()) {
            throw new ForbiddenManipulationException("User cannot modify" +
                    " the enabled status of the user " + username);
        }
        if (isAdmin()) {
            throw new ForbiddenManipulationException("Changing enabled" +
                    " status of the admin users is prohibited");
        }

        this.enabled = enabled;
    }

    /**
     * Returns a number of {@link Game}s the user published.
     *
     * @return the number of {@link Game}s the user published.
     */
    public int getPublishedGamesCount() {
        return getPublishedCreatedGames().size();
    }

    /**
     * Returns a number of {@link Game}s the user rated.
     *
     * @return the number of {@link Game}s the user rated.
     */
    public int getRatedGamesCount() {
        return getPublishedRatedGames().size();
    }

    /**
     * Returns a number of {@link Comment}s the user created.
     *
     * @return the number of {@link Comment}s the user created.
     */
    public int getCommentsCount() {
        return getCommentsForPublishedGames().size();
    }

    private void setGoogleUsername(String googleUsername) {
        this.googleUsername = googleUsername;
    }

    private void setGoogleEmail(String googleEmail)
            throws NotGoogleEmailException {
        if (!googleEmail.contains("@gmail")) {
            throw new NotGoogleEmailException(googleEmail + " is not" +
                    " a google email address");
        }

        this.googleEmail = googleEmail;
    }

    private List<Game> getPublishedCreatedGames() {
        return games.stream().filter(Game::isPublished)
                .collect(Collectors.toList());
    }

    private List<Game> getPublishedRatedGames() {
        return reviews.stream().map(Review::getGame).filter(Game::isPublished)
                .collect(Collectors.toList());
    }

    private List<Comment> getCommentsForPublishedGames() {
        return comments.stream().filter(
                comment -> comment.getGame().isPublished())
                .collect(Collectors.toList());
    }

    /**
     * Checks if two User objects are equal to each other.
     * <p>
     * Objects are equal if:
     * <p>
     * - None of the objects are null and their types are the same;<br>
     * - Their database ids is equal to each other.
     *
     * @param o the object to be checked.
     * @return true if the objects are equal, otherwise false.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;

        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        return id == user.id;
    }

    /**
     * Generates a hash code for the object based on database id.
     *
     * @return the hash code for the object.
     */
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    /**
     * Returns String representation of the object.
     *
     * @return the hash code for the object in the format:
     * "User 'username' (id) with authorities [authorities]"
     */
    @Override
    public String toString() {
        return "User '" + username + "' (" + id + ") with authorities " +
                authorities.toString();
    }

    /**
     * An exception indicating that some sort of forbidden manipulation
     * attempt has been made to the {@link User}.
     */
    public static class ForbiddenManipulationException extends Exception {
        /**
         * Instantiates a new Forbidden Manipulation Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public ForbiddenManipulationException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that certain {@link User} passwords does not
     * match.
     */
    public static class PasswordsNotMatchException extends Exception {
        /**
         * Instantiates a new Passwords Not Match Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public PasswordsNotMatchException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} email format is
     * incorrect.
     */
    public static class EmailFormatException extends Exception {
        /**
         * Instantiates a new Email Format Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public EmailFormatException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} already exists.
     */
    public static class UsernameExistsException extends Exception {
        /**
         * Instantiates a new Username Exists Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public UsernameExistsException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} email is not
     * a google email.
     */
    public static class NotGoogleEmailException extends RuntimeException {
        /**
         * Instantiates a new Not Google Email Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public NotGoogleEmailException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} authority is empty.
     */
    public static class EmptyAuthorityException extends RuntimeException {
        /**
         * Instantiates a new Empty Authority Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public EmptyAuthorityException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} authorities list
     * is empty.
     */
    public static class NoAuthoritiesException extends RuntimeException {
        /**
         * Instantiates a new No Authorities Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public NoAuthoritiesException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} string parameter
     * is empty.
     */
    public static class EmptyStringException extends Exception {
        /**
         * Instantiates a new Empty String Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public EmptyStringException(String s) {
            super(s);
        }
    }

    /**
     * An exception indicating that a certain {@link User} parameter is null.
     */
    public static class NullValueException extends Exception {
        /**
         * Instantiates a new Null Value Exception.
         *
         * @param s the message that indicates the cause of exception.
         */
        public NullValueException(String s) {
            super(s);
        }
    }
}
